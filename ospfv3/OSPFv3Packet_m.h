//
// Generated file, do not edit! Created by nedtool 5.0 from ansa/routing/ospfv3/OSPFv3Packet.msg.
//

#ifndef __INET_OSPFV3PACKET_M_H
#define __INET_OSPFV3PACKET_M_H

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0500
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/networklayer/contract/ipv4/IPv4Address.h"
#include "inet/networklayer/contract/ipv6/IPv6Address.h"
#include "inet/networklayer/common/L3Address.h"
// }}


namespace inet {

/**
 * Enum generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:13</tt> by nedtool.
 * <pre>
 * enum OSPFv3PacketType
 * {
 * 
 *     HELLO_PACKET = 1;
 *     DATABASE_DESCRIPTION = 2;
 *     LSR = 3;
 *     LSU = 4;
 *     LS_ACK = 5;
 * }
 * </pre>
 */
enum OSPFv3PacketType {
    HELLO_PACKET = 1,
    DATABASE_DESCRIPTION = 2,
    LSR = 3,
    LSU = 4,
    LS_ACK = 5
};

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:23</tt> by nedtool.
 * <pre>
 * //Common OSPFv3 packet header - this header is present in every OSPFv3 packet
 * packet OSPFv3Packet
 * {
 *     uint8_t version = 3;
 *     uint8_t type;
 *     uint16_t packetLength;
 * 
 *     IPv4Address routerID;
 *     IPv4Address areaID;
 * 
 *     uint16_t checksum;
 *     uint8_t instanceID;
 * }
 * </pre>
 */
class OSPFv3Packet : public ::omnetpp::cPacket
{
  protected:
    uint8_t version;
    uint8_t type;
    uint16_t packetLength;
    IPv4Address routerID;
    IPv4Address areaID;
    uint16_t checksum;
    uint8_t instanceID;

  private:
    void copy(const OSPFv3Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3Packet&);

  public:
    OSPFv3Packet(const char *name=nullptr, int kind=0);
    OSPFv3Packet(const OSPFv3Packet& other);
    virtual ~OSPFv3Packet();
    OSPFv3Packet& operator=(const OSPFv3Packet& other);
    virtual OSPFv3Packet *dup() const {return new OSPFv3Packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getVersion() const;
    virtual void setVersion(uint8_t version);
    virtual uint8_t getType() const;
    virtual void setType(uint8_t type);
    virtual uint16_t getPacketLength() const;
    virtual void setPacketLength(uint16_t packetLength);
    virtual IPv4Address& getRouterID();
    virtual const IPv4Address& getRouterID() const {return const_cast<OSPFv3Packet*>(this)->getRouterID();}
    virtual void setRouterID(const IPv4Address& routerID);
    virtual IPv4Address& getAreaID();
    virtual const IPv4Address& getAreaID() const {return const_cast<OSPFv3Packet*>(this)->getAreaID();}
    virtual void setAreaID(const IPv4Address& areaID);
    virtual uint16_t getChecksum() const;
    virtual void setChecksum(uint16_t checksum);
    virtual uint8_t getInstanceID() const;
    virtual void setInstanceID(uint8_t instanceID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3Packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3Packet& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from ansa/routing/ospfv3/OSPFv3Packet.msg:37 by nedtool.
 */
struct OSPFv3Options
{
    OSPFv3Options();
    bool reservedOne;
    bool reservedTwo;
    bool dcBit;
    bool rBit;
    bool nBit;
    bool xBit;
    bool eBit;
    bool v6Bit;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const OSPFv3Options& a);
void __doUnpacking(omnetpp::cCommBuffer *b, OSPFv3Options& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3Options& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3Options& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:51</tt> by nedtool.
 * <pre>
 * //***************************************  /
 * //			OSPFv3 test packet			   /
 * //***************************************  /
 * packet OSPFv3TestPacket extends OSPFv3Packet//TODO - remove this at the end
 * {
 *     char text[] = "This is test packet data part for IPv4";
 * }
 * </pre>
 */
class OSPFv3TestPacket : public ::inet::OSPFv3Packet
{
  protected:
    char *text; // array ptr
    unsigned int text_arraysize;

  private:
    void copy(const OSPFv3TestPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3TestPacket&);

  public:
    OSPFv3TestPacket(const char *name=nullptr, int kind=0);
    OSPFv3TestPacket(const OSPFv3TestPacket& other);
    virtual ~OSPFv3TestPacket();
    OSPFv3TestPacket& operator=(const OSPFv3TestPacket& other);
    virtual OSPFv3TestPacket *dup() const {return new OSPFv3TestPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual void setTextArraySize(unsigned int size);
    virtual unsigned int getTextArraySize() const;
    virtual char getText(unsigned int k) const;
    virtual void setText(unsigned int k, char text);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3TestPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3TestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:56</tt> by nedtool.
 * <pre>
 * packet OSPFv3TestPacket6 extends OSPFv3Packet
 * {
 *     char text[] = "This is test packet data part for IPv6";
 * }
 * </pre>
 */
class OSPFv3TestPacket6 : public ::inet::OSPFv3Packet
{
  protected:
    char *text; // array ptr
    unsigned int text_arraysize;

  private:
    void copy(const OSPFv3TestPacket6& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3TestPacket6&);

  public:
    OSPFv3TestPacket6(const char *name=nullptr, int kind=0);
    OSPFv3TestPacket6(const OSPFv3TestPacket6& other);
    virtual ~OSPFv3TestPacket6();
    OSPFv3TestPacket6& operator=(const OSPFv3TestPacket6& other);
    virtual OSPFv3TestPacket6 *dup() const {return new OSPFv3TestPacket6(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual void setTextArraySize(unsigned int size);
    virtual unsigned int getTextArraySize() const;
    virtual char getText(unsigned int k) const;
    virtual void setText(unsigned int k, char text);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3TestPacket6& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3TestPacket6& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:65</tt> by nedtool.
 * <pre>
 * //***************************  
 * //	OSPFv3 hello packet
 * //***************************  
 * packet OSPFv3HelloPacket extends OSPFv3Packet
 * {
 *     uint32_t interfaceID;
 *     uint8_t routerPriority;
 * 
 *     OSPFv3Options options;
 * 
 *     uint16_t helloInterval;
 *     uint16_t deadInterval;
 * 
 *     IPv4Address designatedRouterID;
 *     IPv4Address backupDesignatedRouterID;
 *     IPv4Address neighborID[];
 * }
 * 
 * //*******************************************  
 * //					LSAs
 * //*******************************************  
 * //struct OSPFv3LSAType
 * //{
 * //    bool uBit;	//controls action the router should take when it recieves unknown LSA Function Code
 * //    bool s1Bit;
 * //    bool s2Bit;
 * //    uint16_t lsaFunctionCode;
 * //}
 * </pre>
 */
class OSPFv3HelloPacket : public ::inet::OSPFv3Packet
{
  protected:
    uint32_t interfaceID;
    uint8_t routerPriority;
    OSPFv3Options options;
    uint16_t helloInterval;
    uint16_t deadInterval;
    IPv4Address designatedRouterID;
    IPv4Address backupDesignatedRouterID;
    IPv4Address *neighborID; // array ptr
    unsigned int neighborID_arraysize;

  private:
    void copy(const OSPFv3HelloPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3HelloPacket&);

  public:
    OSPFv3HelloPacket(const char *name=nullptr, int kind=0);
    OSPFv3HelloPacket(const OSPFv3HelloPacket& other);
    virtual ~OSPFv3HelloPacket();
    OSPFv3HelloPacket& operator=(const OSPFv3HelloPacket& other);
    virtual OSPFv3HelloPacket *dup() const {return new OSPFv3HelloPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint32_t getInterfaceID() const;
    virtual void setInterfaceID(uint32_t interfaceID);
    virtual uint8_t getRouterPriority() const;
    virtual void setRouterPriority(uint8_t routerPriority);
    virtual OSPFv3Options& getOptions();
    virtual const OSPFv3Options& getOptions() const {return const_cast<OSPFv3HelloPacket*>(this)->getOptions();}
    virtual void setOptions(const OSPFv3Options& options);
    virtual uint16_t getHelloInterval() const;
    virtual void setHelloInterval(uint16_t helloInterval);
    virtual uint16_t getDeadInterval() const;
    virtual void setDeadInterval(uint16_t deadInterval);
    virtual IPv4Address& getDesignatedRouterID();
    virtual const IPv4Address& getDesignatedRouterID() const {return const_cast<OSPFv3HelloPacket*>(this)->getDesignatedRouterID();}
    virtual void setDesignatedRouterID(const IPv4Address& designatedRouterID);
    virtual IPv4Address& getBackupDesignatedRouterID();
    virtual const IPv4Address& getBackupDesignatedRouterID() const {return const_cast<OSPFv3HelloPacket*>(this)->getBackupDesignatedRouterID();}
    virtual void setBackupDesignatedRouterID(const IPv4Address& backupDesignatedRouterID);
    virtual void setNeighborIDArraySize(unsigned int size);
    virtual unsigned int getNeighborIDArraySize() const;
    virtual IPv4Address& getNeighborID(unsigned int k);
    virtual const IPv4Address& getNeighborID(unsigned int k) const {return const_cast<OSPFv3HelloPacket*>(this)->getNeighborID(k);}
    virtual void setNeighborID(unsigned int k, const IPv4Address& neighborID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3HelloPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3HelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:93</tt> by nedtool.
 * <pre>
 * //Common LSA Header - this header is present in every LSA
 * //triplet {lsType, linkStateID, advertisingRouter} uniquely identify the LSA
 * class OSPFv3LSAHeader
 * {
 *     uint16_t lsaAge;
 *     uint16_t lsaType;
 * 
 *     IPv4Address linkStateID;
 *     IPv4Address advertisingRouter;
 * 
 *     uint32_t lsaSequenceNumber;
 * 
 *     uint16_t lsaChecksum;
 *     uint16_t lsaLength;
 * }
 * </pre>
 */
class OSPFv3LSAHeader : public ::omnetpp::cObject
{
  protected:
    uint16_t lsaAge;
    uint16_t lsaType;
    IPv4Address linkStateID;
    IPv4Address advertisingRouter;
    uint32_t lsaSequenceNumber;
    uint16_t lsaChecksum;
    uint16_t lsaLength;

  private:
    void copy(const OSPFv3LSAHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3LSAHeader&);

  public:
    OSPFv3LSAHeader();
    OSPFv3LSAHeader(const OSPFv3LSAHeader& other);
    virtual ~OSPFv3LSAHeader();
    OSPFv3LSAHeader& operator=(const OSPFv3LSAHeader& other);
    virtual OSPFv3LSAHeader *dup() const {return new OSPFv3LSAHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getLsaAge() const;
    virtual void setLsaAge(uint16_t lsaAge);
    virtual uint16_t getLsaType() const;
    virtual void setLsaType(uint16_t lsaType);
    virtual IPv4Address& getLinkStateID();
    virtual const IPv4Address& getLinkStateID() const {return const_cast<OSPFv3LSAHeader*>(this)->getLinkStateID();}
    virtual void setLinkStateID(const IPv4Address& linkStateID);
    virtual IPv4Address& getAdvertisingRouter();
    virtual const IPv4Address& getAdvertisingRouter() const {return const_cast<OSPFv3LSAHeader*>(this)->getAdvertisingRouter();}
    virtual void setAdvertisingRouter(const IPv4Address& advertisingRouter);
    virtual uint32_t getLsaSequenceNumber() const;
    virtual void setLsaSequenceNumber(uint32_t lsaSequenceNumber);
    virtual uint16_t getLsaChecksum() const;
    virtual void setLsaChecksum(uint16_t lsaChecksum);
    virtual uint16_t getLsaLength() const;
    virtual void setLsaLength(uint16_t lsaLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LSAHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSAHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:106</tt> by nedtool.
 * <pre>
 * class OSPFv3LSA
 * {
 *     OSPFv3LSAHeader header;
 * }
 * </pre>
 */
class OSPFv3LSA : public ::omnetpp::cObject
{
  protected:
    OSPFv3LSAHeader header;

  private:
    void copy(const OSPFv3LSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3LSA&);

  public:
    OSPFv3LSA();
    OSPFv3LSA(const OSPFv3LSA& other);
    virtual ~OSPFv3LSA();
    OSPFv3LSA& operator=(const OSPFv3LSA& other);
    virtual OSPFv3LSA *dup() const {return new OSPFv3LSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual OSPFv3LSAHeader& getHeader();
    virtual const OSPFv3LSAHeader& getHeader() const {return const_cast<OSPFv3LSA*>(this)->getHeader();}
    virtual void setHeader(const OSPFv3LSAHeader& header);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSA& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:112</tt> by nedtool.
 * <pre>
 * //LSA Function Code
 * enum OSPFv3LSAFunctionCode
 * {
 * 
 *     ROUTER_LSA = 1;
 *     NETWORK_LSA = 2;
 *     INTER_AREA_PREFIX_LSA = 3;
 *     INTER_AREA_ROUTER_LSA = 4;
 *     AS_EXTERNAL_LSA = 5;
 *     DEPRECATED = 6;
 *     NSSA_LSA = 7;
 *     LINK_LSA = 8;
 *     INTRA_AREA_PREFIX_LSA = 9;
 * }
 * </pre>
 */
enum OSPFv3LSAFunctionCode {
    ROUTER_LSA = 1,
    NETWORK_LSA = 2,
    INTER_AREA_PREFIX_LSA = 3,
    INTER_AREA_ROUTER_LSA = 4,
    AS_EXTERNAL_LSA = 5,
    DEPRECATED = 6,
    NSSA_LSA = 7,
    LINK_LSA = 8,
    INTRA_AREA_PREFIX_LSA = 9
};

/**
 * Struct generated from ansa/routing/ospfv3/OSPFv3Packet.msg:126 by nedtool.
 */
struct OSPFv3LSAPrefix
{
    OSPFv3LSAPrefix();
    bool dnBit;
    bool pBit;
    bool xBit;
    bool laBit;
    bool nuBit;
    uint8_t prefixLen;
    L3Address addressPrefix;
    uint16_t metric;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const OSPFv3LSAPrefix& a);
void __doUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSAPrefix& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LSAPrefix& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSAPrefix& obj) { __doUnpacking(b, obj); }

/**
 * Struct generated from ansa/routing/ospfv3/OSPFv3Packet.msg:141 by nedtool.
 */
struct OSPFv3LinkLSAPrefix
{
    OSPFv3LinkLSAPrefix();
    bool dnBit;
    bool pBit;
    bool xBit;
    bool laBit;
    bool nuBit;
    uint8_t prefixLen;
    L3Address addressPrefix;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const OSPFv3LinkLSAPrefix& a);
void __doUnpacking(omnetpp::cCommBuffer *b, OSPFv3LinkLSAPrefix& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LinkLSAPrefix& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LinkLSAPrefix& obj) { __doUnpacking(b, obj); }

/**
 * Enum generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:156</tt> by nedtool.
 * <pre>
 * //************* Router LSA *************  /
 * enum OSPFv3RouterLSAType
 * {
 * 
 *     POINT_TO_POINT = 1;
 *     TRANSIT_NETWORK = 2;
 *     RESERVED = 3;
 *     VIRTUAL_LINK = 4;
 * }
 * </pre>
 */
enum OSPFv3RouterLSAType {
    POINT_TO_POINT = 1,
    TRANSIT_NETWORK = 2,
    RESERVED = 3,
    VIRTUAL_LINK = 4
};

/**
 * Struct generated from ansa/routing/ospfv3/OSPFv3Packet.msg:164 by nedtool.
 */
struct OSPFv3RouterLSABody
{
    OSPFv3RouterLSABody();
    uint8_t type;
    uint16_t metric;
    uint32_t interfaceID;
    uint32_t neighborInterfaceID;
    IPv4Address neighborRouterID;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const OSPFv3RouterLSABody& a);
void __doUnpacking(omnetpp::cCommBuffer *b, OSPFv3RouterLSABody& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3RouterLSABody& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3RouterLSABody& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:174</tt> by nedtool.
 * <pre>
 * class OSPFv3RouterLSA extends OSPFv3LSA
 * {
 *     bool ntBit;
 *     bool xBit;
 *     bool vBit;
 *     bool eBit;
 *     bool bBit;
 *     OSPFv3Options ospfOptions;
 * 
 *     OSPFv3RouterLSABody routers[];
 * }
 * </pre>
 */
class OSPFv3RouterLSA : public ::inet::OSPFv3LSA
{
  protected:
    bool ntBit;
    bool xBit;
    bool vBit;
    bool eBit;
    bool bBit;
    OSPFv3Options ospfOptions;
    OSPFv3RouterLSABody *routers; // array ptr
    unsigned int routers_arraysize;

  private:
    void copy(const OSPFv3RouterLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3RouterLSA&);

  public:
    OSPFv3RouterLSA();
    OSPFv3RouterLSA(const OSPFv3RouterLSA& other);
    virtual ~OSPFv3RouterLSA();
    OSPFv3RouterLSA& operator=(const OSPFv3RouterLSA& other);
    virtual OSPFv3RouterLSA *dup() const {return new OSPFv3RouterLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual bool getNtBit() const;
    virtual void setNtBit(bool ntBit);
    virtual bool getXBit() const;
    virtual void setXBit(bool xBit);
    virtual bool getVBit() const;
    virtual void setVBit(bool vBit);
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual OSPFv3Options& getOspfOptions();
    virtual const OSPFv3Options& getOspfOptions() const {return const_cast<OSPFv3RouterLSA*>(this)->getOspfOptions();}
    virtual void setOspfOptions(const OSPFv3Options& ospfOptions);
    virtual void setRoutersArraySize(unsigned int size);
    virtual unsigned int getRoutersArraySize() const;
    virtual OSPFv3RouterLSABody& getRouters(unsigned int k);
    virtual const OSPFv3RouterLSABody& getRouters(unsigned int k) const {return const_cast<OSPFv3RouterLSA*>(this)->getRouters(k);}
    virtual void setRouters(unsigned int k, const OSPFv3RouterLSABody& routers);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3RouterLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3RouterLSA& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:187</tt> by nedtool.
 * <pre>
 * //******************* Network LSA ******************  /
 * packet OSPFv3NetworkLSA extends OSPFv3LSA
 * {
 *     OSPFv3Options ospfOptions;
 * 
 *     IPv4Address attachedRouter[];
 * }
 * </pre>
 */
class OSPFv3NetworkLSA : public ::inet::OSPFv3LSA
{
  protected:
    OSPFv3Options ospfOptions;
    IPv4Address *attachedRouter; // array ptr
    unsigned int attachedRouter_arraysize;

  private:
    void copy(const OSPFv3NetworkLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3NetworkLSA&);

  public:
    OSPFv3NetworkLSA();
    OSPFv3NetworkLSA(const OSPFv3NetworkLSA& other);
    virtual ~OSPFv3NetworkLSA();
    OSPFv3NetworkLSA& operator=(const OSPFv3NetworkLSA& other);
    virtual OSPFv3NetworkLSA *dup() const {return new OSPFv3NetworkLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual OSPFv3Options& getOspfOptions();
    virtual const OSPFv3Options& getOspfOptions() const {return const_cast<OSPFv3NetworkLSA*>(this)->getOspfOptions();}
    virtual void setOspfOptions(const OSPFv3Options& ospfOptions);
    virtual void setAttachedRouterArraySize(unsigned int size);
    virtual unsigned int getAttachedRouterArraySize() const;
    virtual IPv4Address& getAttachedRouter(unsigned int k);
    virtual const IPv4Address& getAttachedRouter(unsigned int k) const {return const_cast<OSPFv3NetworkLSA*>(this)->getAttachedRouter(k);}
    virtual void setAttachedRouter(unsigned int k, const IPv4Address& attachedRouter);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3NetworkLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3NetworkLSA& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:195</tt> by nedtool.
 * <pre>
 * //************* Inter-Area-Prefix-LSAs ************  /
 * packet OSPFv3InterAreaPrefixLSA extends OSPFv3LSA
 * {
 *     bool dnBit;
 *     bool pBit;
 *     bool xBit;
 *     bool laBit;
 *     bool nuBit;
 *     uint32_t metric;
 *     uint8_t prefixLen;
 *     L3Address prefix;
 * }
 * </pre>
 */
class OSPFv3InterAreaPrefixLSA : public ::inet::OSPFv3LSA
{
  protected:
    bool dnBit;
    bool pBit;
    bool xBit;
    bool laBit;
    bool nuBit;
    uint32_t metric;
    uint8_t prefixLen;
    L3Address prefix;

  private:
    void copy(const OSPFv3InterAreaPrefixLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3InterAreaPrefixLSA&);

  public:
    OSPFv3InterAreaPrefixLSA();
    OSPFv3InterAreaPrefixLSA(const OSPFv3InterAreaPrefixLSA& other);
    virtual ~OSPFv3InterAreaPrefixLSA();
    OSPFv3InterAreaPrefixLSA& operator=(const OSPFv3InterAreaPrefixLSA& other);
    virtual OSPFv3InterAreaPrefixLSA *dup() const {return new OSPFv3InterAreaPrefixLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual bool getDnBit() const;
    virtual void setDnBit(bool dnBit);
    virtual bool getPBit() const;
    virtual void setPBit(bool pBit);
    virtual bool getXBit() const;
    virtual void setXBit(bool xBit);
    virtual bool getLaBit() const;
    virtual void setLaBit(bool laBit);
    virtual bool getNuBit() const;
    virtual void setNuBit(bool nuBit);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual uint8_t getPrefixLen() const;
    virtual void setPrefixLen(uint8_t prefixLen);
    virtual L3Address& getPrefix();
    virtual const L3Address& getPrefix() const {return const_cast<OSPFv3InterAreaPrefixLSA*>(this)->getPrefix();}
    virtual void setPrefix(const L3Address& prefix);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3InterAreaPrefixLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3InterAreaPrefixLSA& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:208</tt> by nedtool.
 * <pre>
 * //************* Inter-Area-Router-LSAs ***********  /
 * packet OSPFv3InterAreaRouterLSA extends OSPFv3LSA
 * {
 *     OSPFv3Options ospfOptions;
 *     uint32_t metric;
 *     uint32_t destinationRouter;
 * }
 * </pre>
 */
class OSPFv3InterAreaRouterLSA : public ::inet::OSPFv3LSA
{
  protected:
    OSPFv3Options ospfOptions;
    uint32_t metric;
    uint32_t destinationRouter;

  private:
    void copy(const OSPFv3InterAreaRouterLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3InterAreaRouterLSA&);

  public:
    OSPFv3InterAreaRouterLSA();
    OSPFv3InterAreaRouterLSA(const OSPFv3InterAreaRouterLSA& other);
    virtual ~OSPFv3InterAreaRouterLSA();
    OSPFv3InterAreaRouterLSA& operator=(const OSPFv3InterAreaRouterLSA& other);
    virtual OSPFv3InterAreaRouterLSA *dup() const {return new OSPFv3InterAreaRouterLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual OSPFv3Options& getOspfOptions();
    virtual const OSPFv3Options& getOspfOptions() const {return const_cast<OSPFv3InterAreaRouterLSA*>(this)->getOspfOptions();}
    virtual void setOspfOptions(const OSPFv3Options& ospfOptions);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual uint32_t getDestinationRouter() const;
    virtual void setDestinationRouter(uint32_t destinationRouter);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3InterAreaRouterLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3InterAreaRouterLSA& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:216</tt> by nedtool.
 * <pre>
 * //***************   AS-External-LSAs   *************  /
 * packet OSPFv3ASExternalLSA extends OSPFv3LSA
 * {
 *     bool eBit;
 *     bool fBit;
 *     bool tBit;
 *     uint32_t metric;
 * 
 *     uint16_t referencedLSType;
 * 
 *     IPv6Address forwardingAddress;
 *     uint32_t externalRouteTag;
 *     uint32_t referencedLSID;
 * }
 * </pre>
 */
class OSPFv3ASExternalLSA : public ::inet::OSPFv3LSA
{
  protected:
    bool eBit;
    bool fBit;
    bool tBit;
    uint32_t metric;
    uint16_t referencedLSType;
    IPv6Address forwardingAddress;
    uint32_t externalRouteTag;
    uint32_t referencedLSID;

  private:
    void copy(const OSPFv3ASExternalLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3ASExternalLSA&);

  public:
    OSPFv3ASExternalLSA();
    OSPFv3ASExternalLSA(const OSPFv3ASExternalLSA& other);
    virtual ~OSPFv3ASExternalLSA();
    OSPFv3ASExternalLSA& operator=(const OSPFv3ASExternalLSA& other);
    virtual OSPFv3ASExternalLSA *dup() const {return new OSPFv3ASExternalLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getFBit() const;
    virtual void setFBit(bool fBit);
    virtual bool getTBit() const;
    virtual void setTBit(bool tBit);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual uint16_t getReferencedLSType() const;
    virtual void setReferencedLSType(uint16_t referencedLSType);
    virtual IPv6Address& getForwardingAddress();
    virtual const IPv6Address& getForwardingAddress() const {return const_cast<OSPFv3ASExternalLSA*>(this)->getForwardingAddress();}
    virtual void setForwardingAddress(const IPv6Address& forwardingAddress);
    virtual uint32_t getExternalRouteTag() const;
    virtual void setExternalRouteTag(uint32_t externalRouteTag);
    virtual uint32_t getReferencedLSID() const;
    virtual void setReferencedLSID(uint32_t referencedLSID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3ASExternalLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3ASExternalLSA& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:235</tt> by nedtool.
 * <pre>
 * //******************   NSSA-LSAs  *****************  /
 * // Routers in a Not-so-stubby-area (NSSA) do not receive external LSAs from Area Border Routers,
 * // but are allowed to send external routing information for redistribution.
 * // They use type 7 LSAs to tell the ABRs about these external routes,
 * // which the Area Border Router then translates to type 5 external LSAs and floods as normal to the rest of the OSPF network
 * packet OSPFv3NssaLSA extends OSPFv3LSA
 * {
 *     bool eBit;
 *     bool fBit;
 *     bool tBit;
 *     uint32_t metric;
 * 
 *     OSPFv3LSAPrefix prefOptions;
 *     uint16_t referencedLSType;
 * 
 *     IPv6Address forwardingAddress;
 *     uint32_t externalRouteTag;
 *     uint32_t referencedLSID;
 * }
 * </pre>
 */
class OSPFv3NssaLSA : public ::inet::OSPFv3LSA
{
  protected:
    bool eBit;
    bool fBit;
    bool tBit;
    uint32_t metric;
    OSPFv3LSAPrefix prefOptions;
    uint16_t referencedLSType;
    IPv6Address forwardingAddress;
    uint32_t externalRouteTag;
    uint32_t referencedLSID;

  private:
    void copy(const OSPFv3NssaLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3NssaLSA&);

  public:
    OSPFv3NssaLSA();
    OSPFv3NssaLSA(const OSPFv3NssaLSA& other);
    virtual ~OSPFv3NssaLSA();
    OSPFv3NssaLSA& operator=(const OSPFv3NssaLSA& other);
    virtual OSPFv3NssaLSA *dup() const {return new OSPFv3NssaLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getFBit() const;
    virtual void setFBit(bool fBit);
    virtual bool getTBit() const;
    virtual void setTBit(bool tBit);
    virtual uint32_t getMetric() const;
    virtual void setMetric(uint32_t metric);
    virtual OSPFv3LSAPrefix& getPrefOptions();
    virtual const OSPFv3LSAPrefix& getPrefOptions() const {return const_cast<OSPFv3NssaLSA*>(this)->getPrefOptions();}
    virtual void setPrefOptions(const OSPFv3LSAPrefix& prefOptions);
    virtual uint16_t getReferencedLSType() const;
    virtual void setReferencedLSType(uint16_t referencedLSType);
    virtual IPv6Address& getForwardingAddress();
    virtual const IPv6Address& getForwardingAddress() const {return const_cast<OSPFv3NssaLSA*>(this)->getForwardingAddress();}
    virtual void setForwardingAddress(const IPv6Address& forwardingAddress);
    virtual uint32_t getExternalRouteTag() const;
    virtual void setExternalRouteTag(uint32_t externalRouteTag);
    virtual uint32_t getReferencedLSID() const;
    virtual void setReferencedLSID(uint32_t referencedLSID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3NssaLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3NssaLSA& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:253</tt> by nedtool.
 * <pre>
 * //*************** Link-LSAs ***********************  /
 * // A link-local only LSA for OSPFv3. A Type 8 LSA is used to give 
 * // information about link-local addresses and a list of IPv6 addresses on the link.
 * packet OSPFv3LinkLSA extends OSPFv3LSA
 * {
 *     uint8_t routerPriority;
 *     OSPFv3Options ospfOptions;
 * 
 *     L3Address linkLocalInterfaceAdd;
 * 
 *     uint32_t numPrefixes;
 *     OSPFv3LinkLSAPrefix prefixes[];
 * }
 * </pre>
 */
class OSPFv3LinkLSA : public ::inet::OSPFv3LSA
{
  protected:
    uint8_t routerPriority;
    OSPFv3Options ospfOptions;
    L3Address linkLocalInterfaceAdd;
    uint32_t numPrefixes;
    OSPFv3LinkLSAPrefix *prefixes; // array ptr
    unsigned int prefixes_arraysize;

  private:
    void copy(const OSPFv3LinkLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3LinkLSA&);

  public:
    OSPFv3LinkLSA();
    OSPFv3LinkLSA(const OSPFv3LinkLSA& other);
    virtual ~OSPFv3LinkLSA();
    OSPFv3LinkLSA& operator=(const OSPFv3LinkLSA& other);
    virtual OSPFv3LinkLSA *dup() const {return new OSPFv3LinkLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getRouterPriority() const;
    virtual void setRouterPriority(uint8_t routerPriority);
    virtual OSPFv3Options& getOspfOptions();
    virtual const OSPFv3Options& getOspfOptions() const {return const_cast<OSPFv3LinkLSA*>(this)->getOspfOptions();}
    virtual void setOspfOptions(const OSPFv3Options& ospfOptions);
    virtual L3Address& getLinkLocalInterfaceAdd();
    virtual const L3Address& getLinkLocalInterfaceAdd() const {return const_cast<OSPFv3LinkLSA*>(this)->getLinkLocalInterfaceAdd();}
    virtual void setLinkLocalInterfaceAdd(const L3Address& linkLocalInterfaceAdd);
    virtual uint32_t getNumPrefixes() const;
    virtual void setNumPrefixes(uint32_t numPrefixes);
    virtual void setPrefixesArraySize(unsigned int size);
    virtual unsigned int getPrefixesArraySize() const;
    virtual OSPFv3LinkLSAPrefix& getPrefixes(unsigned int k);
    virtual const OSPFv3LinkLSAPrefix& getPrefixes(unsigned int k) const {return const_cast<OSPFv3LinkLSA*>(this)->getPrefixes(k);}
    virtual void setPrefixes(unsigned int k, const OSPFv3LinkLSAPrefix& prefixes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LinkLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LinkLSA& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:265</tt> by nedtool.
 * <pre>
 * //************** Intra-Area-Prefix-LSAs ***********  /
 * packet OSPFv3IntraAreaPrefixLSA extends OSPFv3LSA
 * {
 *     uint16_t numPrefixes;
 *     uint16_t referencedLSType;
 *     IPv4Address referencedLSID;
 *     IPv4Address referencedAdvRtr;
 * 
 *     OSPFv3LSAPrefix prefixes[];
 * }
 * 
 * //***********************************************  
 * //			Database Description Packet
 * //***********************************************
 * </pre>
 */
class OSPFv3IntraAreaPrefixLSA : public ::inet::OSPFv3LSA
{
  protected:
    uint16_t numPrefixes;
    uint16_t referencedLSType;
    IPv4Address referencedLSID;
    IPv4Address referencedAdvRtr;
    OSPFv3LSAPrefix *prefixes; // array ptr
    unsigned int prefixes_arraysize;

  private:
    void copy(const OSPFv3IntraAreaPrefixLSA& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3IntraAreaPrefixLSA&);

  public:
    OSPFv3IntraAreaPrefixLSA();
    OSPFv3IntraAreaPrefixLSA(const OSPFv3IntraAreaPrefixLSA& other);
    virtual ~OSPFv3IntraAreaPrefixLSA();
    OSPFv3IntraAreaPrefixLSA& operator=(const OSPFv3IntraAreaPrefixLSA& other);
    virtual OSPFv3IntraAreaPrefixLSA *dup() const {return new OSPFv3IntraAreaPrefixLSA(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getNumPrefixes() const;
    virtual void setNumPrefixes(uint16_t numPrefixes);
    virtual uint16_t getReferencedLSType() const;
    virtual void setReferencedLSType(uint16_t referencedLSType);
    virtual IPv4Address& getReferencedLSID();
    virtual const IPv4Address& getReferencedLSID() const {return const_cast<OSPFv3IntraAreaPrefixLSA*>(this)->getReferencedLSID();}
    virtual void setReferencedLSID(const IPv4Address& referencedLSID);
    virtual IPv4Address& getReferencedAdvRtr();
    virtual const IPv4Address& getReferencedAdvRtr() const {return const_cast<OSPFv3IntraAreaPrefixLSA*>(this)->getReferencedAdvRtr();}
    virtual void setReferencedAdvRtr(const IPv4Address& referencedAdvRtr);
    virtual void setPrefixesArraySize(unsigned int size);
    virtual unsigned int getPrefixesArraySize() const;
    virtual OSPFv3LSAPrefix& getPrefixes(unsigned int k);
    virtual const OSPFv3LSAPrefix& getPrefixes(unsigned int k) const {return const_cast<OSPFv3IntraAreaPrefixLSA*>(this)->getPrefixes(k);}
    virtual void setPrefixes(unsigned int k, const OSPFv3LSAPrefix& prefixes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3IntraAreaPrefixLSA& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3IntraAreaPrefixLSA& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from ansa/routing/ospfv3/OSPFv3Packet.msg:280 by nedtool.
 */
struct OSPFv3DDOptions
{
    OSPFv3DDOptions();
    bool iBit;
    bool mBit;
    bool msBit;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const OSPFv3DDOptions& a);
void __doUnpacking(omnetpp::cCommBuffer *b, OSPFv3DDOptions& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3DDOptions& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3DDOptions& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:286</tt> by nedtool.
 * <pre>
 * packet OSPFv3DatabaseDescription extends OSPFv3Packet
 * {
 *     OSPFv3Options options;
 * 
 *     uint16_t interfaceMTU;
 *     OSPFv3DDOptions ddOptions;
 * 
 *     uint32_t sequenceNumber;
 * 
 *     OSPFv3LSAHeader lsaHeaders[];
 * }
 * 
 * 
 * //***********************************************  /
 * //*				Link State Request				  //
 * //***********************************************  /
 * </pre>
 */
class OSPFv3DatabaseDescription : public ::inet::OSPFv3Packet
{
  protected:
    OSPFv3Options options;
    uint16_t interfaceMTU;
    OSPFv3DDOptions ddOptions;
    uint32_t sequenceNumber;
    OSPFv3LSAHeader *lsaHeaders; // array ptr
    unsigned int lsaHeaders_arraysize;

  private:
    void copy(const OSPFv3DatabaseDescription& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3DatabaseDescription&);

  public:
    OSPFv3DatabaseDescription(const char *name=nullptr, int kind=0);
    OSPFv3DatabaseDescription(const OSPFv3DatabaseDescription& other);
    virtual ~OSPFv3DatabaseDescription();
    OSPFv3DatabaseDescription& operator=(const OSPFv3DatabaseDescription& other);
    virtual OSPFv3DatabaseDescription *dup() const {return new OSPFv3DatabaseDescription(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual OSPFv3Options& getOptions();
    virtual const OSPFv3Options& getOptions() const {return const_cast<OSPFv3DatabaseDescription*>(this)->getOptions();}
    virtual void setOptions(const OSPFv3Options& options);
    virtual uint16_t getInterfaceMTU() const;
    virtual void setInterfaceMTU(uint16_t interfaceMTU);
    virtual OSPFv3DDOptions& getDdOptions();
    virtual const OSPFv3DDOptions& getDdOptions() const {return const_cast<OSPFv3DatabaseDescription*>(this)->getDdOptions();}
    virtual void setDdOptions(const OSPFv3DDOptions& ddOptions);
    virtual uint32_t getSequenceNumber() const;
    virtual void setSequenceNumber(uint32_t sequenceNumber);
    virtual void setLsaHeadersArraySize(unsigned int size);
    virtual unsigned int getLsaHeadersArraySize() const;
    virtual OSPFv3LSAHeader& getLsaHeaders(unsigned int k);
    virtual const OSPFv3LSAHeader& getLsaHeaders(unsigned int k) const {return const_cast<OSPFv3DatabaseDescription*>(this)->getLsaHeaders(k);}
    virtual void setLsaHeaders(unsigned int k, const OSPFv3LSAHeader& lsaHeaders);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3DatabaseDescription& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3DatabaseDescription& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from ansa/routing/ospfv3/OSPFv3Packet.msg:303 by nedtool.
 */
struct OSPFv3LSRequest
{
    OSPFv3LSRequest();
    uint16_t lsaType;
    IPv4Address lsaID;
    IPv4Address advertisingRouter;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const OSPFv3LSRequest& a);
void __doUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSRequest& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LSRequest& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSRequest& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:310</tt> by nedtool.
 * <pre>
 * //Link State Request packet
 * packet OSPFv3LinkStateRequest extends OSPFv3Packet
 * {
 *     OSPFv3LSRequest requests[];
 * }
 * 
 * //***********************************************  /
 * //*				Link State Update				   /
 * //***********************************************  /
 * </pre>
 */
class OSPFv3LinkStateRequest : public ::inet::OSPFv3Packet
{
  protected:
    OSPFv3LSRequest *requests; // array ptr
    unsigned int requests_arraysize;

  private:
    void copy(const OSPFv3LinkStateRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3LinkStateRequest&);

  public:
    OSPFv3LinkStateRequest(const char *name=nullptr, int kind=0);
    OSPFv3LinkStateRequest(const OSPFv3LinkStateRequest& other);
    virtual ~OSPFv3LinkStateRequest();
    OSPFv3LinkStateRequest& operator=(const OSPFv3LinkStateRequest& other);
    virtual OSPFv3LinkStateRequest *dup() const {return new OSPFv3LinkStateRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual void setRequestsArraySize(unsigned int size);
    virtual unsigned int getRequestsArraySize() const;
    virtual OSPFv3LSRequest& getRequests(unsigned int k);
    virtual const OSPFv3LSRequest& getRequests(unsigned int k) const {return const_cast<OSPFv3LinkStateRequest*>(this)->getRequests(k);}
    virtual void setRequests(unsigned int k, const OSPFv3LSRequest& requests);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LinkStateRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LinkStateRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:319</tt> by nedtool.
 * <pre>
 * //Link State Update packet
 * packet OSPFv3LSUpdate extends OSPFv3Packet
 * {
 *     uint32_t lsaCount;	//specifies the number of LSAs sent in a single packet
 * 
 *     OSPFv3RouterLSA RouterLSAs[];
 *     OSPFv3NetworkLSA NetworkLSAs[];
 *     OSPFv3InterAreaPrefixLSA InterAreaPrefixLSAs[];
 *     OSPFv3LinkLSA LinkLSAs[];
 *     OSPFv3IntraAreaPrefixLSA IntraAreaPrefixLSAs[];
 * 
 * //    OSPFv3LSA LSAs[];
 *     //TODO - template for any LSA??
 * }
 * 
 * //***********************************************  /
 * //*			Link State Acknowledgement			   /
 * //***********************************************  /
 * </pre>
 */
class OSPFv3LSUpdate : public ::inet::OSPFv3Packet
{
  protected:
    uint32_t lsaCount;
    OSPFv3RouterLSA *RouterLSAs; // array ptr
    unsigned int RouterLSAs_arraysize;
    OSPFv3NetworkLSA *NetworkLSAs; // array ptr
    unsigned int NetworkLSAs_arraysize;
    OSPFv3InterAreaPrefixLSA *InterAreaPrefixLSAs; // array ptr
    unsigned int InterAreaPrefixLSAs_arraysize;
    OSPFv3LinkLSA *LinkLSAs; // array ptr
    unsigned int LinkLSAs_arraysize;
    OSPFv3IntraAreaPrefixLSA *IntraAreaPrefixLSAs; // array ptr
    unsigned int IntraAreaPrefixLSAs_arraysize;

  private:
    void copy(const OSPFv3LSUpdate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3LSUpdate&);

  public:
    OSPFv3LSUpdate(const char *name=nullptr, int kind=0);
    OSPFv3LSUpdate(const OSPFv3LSUpdate& other);
    virtual ~OSPFv3LSUpdate();
    OSPFv3LSUpdate& operator=(const OSPFv3LSUpdate& other);
    virtual OSPFv3LSUpdate *dup() const {return new OSPFv3LSUpdate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint32_t getLsaCount() const;
    virtual void setLsaCount(uint32_t lsaCount);
    virtual void setRouterLSAsArraySize(unsigned int size);
    virtual unsigned int getRouterLSAsArraySize() const;
    virtual OSPFv3RouterLSA& getRouterLSAs(unsigned int k);
    virtual const OSPFv3RouterLSA& getRouterLSAs(unsigned int k) const {return const_cast<OSPFv3LSUpdate*>(this)->getRouterLSAs(k);}
    virtual void setRouterLSAs(unsigned int k, const OSPFv3RouterLSA& RouterLSAs);
    virtual void setNetworkLSAsArraySize(unsigned int size);
    virtual unsigned int getNetworkLSAsArraySize() const;
    virtual OSPFv3NetworkLSA& getNetworkLSAs(unsigned int k);
    virtual const OSPFv3NetworkLSA& getNetworkLSAs(unsigned int k) const {return const_cast<OSPFv3LSUpdate*>(this)->getNetworkLSAs(k);}
    virtual void setNetworkLSAs(unsigned int k, const OSPFv3NetworkLSA& NetworkLSAs);
    virtual void setInterAreaPrefixLSAsArraySize(unsigned int size);
    virtual unsigned int getInterAreaPrefixLSAsArraySize() const;
    virtual OSPFv3InterAreaPrefixLSA& getInterAreaPrefixLSAs(unsigned int k);
    virtual const OSPFv3InterAreaPrefixLSA& getInterAreaPrefixLSAs(unsigned int k) const {return const_cast<OSPFv3LSUpdate*>(this)->getInterAreaPrefixLSAs(k);}
    virtual void setInterAreaPrefixLSAs(unsigned int k, const OSPFv3InterAreaPrefixLSA& InterAreaPrefixLSAs);
    virtual void setLinkLSAsArraySize(unsigned int size);
    virtual unsigned int getLinkLSAsArraySize() const;
    virtual OSPFv3LinkLSA& getLinkLSAs(unsigned int k);
    virtual const OSPFv3LinkLSA& getLinkLSAs(unsigned int k) const {return const_cast<OSPFv3LSUpdate*>(this)->getLinkLSAs(k);}
    virtual void setLinkLSAs(unsigned int k, const OSPFv3LinkLSA& LinkLSAs);
    virtual void setIntraAreaPrefixLSAsArraySize(unsigned int size);
    virtual unsigned int getIntraAreaPrefixLSAsArraySize() const;
    virtual OSPFv3IntraAreaPrefixLSA& getIntraAreaPrefixLSAs(unsigned int k);
    virtual const OSPFv3IntraAreaPrefixLSA& getIntraAreaPrefixLSAs(unsigned int k) const {return const_cast<OSPFv3LSUpdate*>(this)->getIntraAreaPrefixLSAs(k);}
    virtual void setIntraAreaPrefixLSAs(unsigned int k, const OSPFv3IntraAreaPrefixLSA& IntraAreaPrefixLSAs);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LSUpdate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSUpdate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ansa/routing/ospfv3/OSPFv3Packet.msg:337</tt> by nedtool.
 * <pre>
 * //Link State Acknowledgement packet
 * packet OSPFv3LSAck extends OSPFv3Packet
 * {
 *     uint32_t lsas;
 *     OSPFv3LSAHeader lsaHeaders[];
 * }
 * </pre>
 */
class OSPFv3LSAck : public ::inet::OSPFv3Packet
{
  protected:
    uint32_t lsas;
    OSPFv3LSAHeader *lsaHeaders; // array ptr
    unsigned int lsaHeaders_arraysize;

  private:
    void copy(const OSPFv3LSAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OSPFv3LSAck&);

  public:
    OSPFv3LSAck(const char *name=nullptr, int kind=0);
    OSPFv3LSAck(const OSPFv3LSAck& other);
    virtual ~OSPFv3LSAck();
    OSPFv3LSAck& operator=(const OSPFv3LSAck& other);
    virtual OSPFv3LSAck *dup() const {return new OSPFv3LSAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint32_t getLsas() const;
    virtual void setLsas(uint32_t lsas);
    virtual void setLsaHeadersArraySize(unsigned int size);
    virtual unsigned int getLsaHeadersArraySize() const;
    virtual OSPFv3LSAHeader& getLsaHeaders(unsigned int k);
    virtual const OSPFv3LSAHeader& getLsaHeaders(unsigned int k) const {return const_cast<OSPFv3LSAck*>(this)->getLsaHeaders(k);}
    virtual void setLsaHeaders(unsigned int k, const OSPFv3LSAHeader& lsaHeaders);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OSPFv3LSAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OSPFv3LSAck& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_OSPFV3PACKET_M_H

